# new, initialize and allocate

Экземпляр класса создаётся при вызове `new` этого класса:

```
person = Person.new
```

Здесь `person` — экземпляр класса `Person`.

Пока что мы ничего не можем сделать с `person`, так что давайте определим некоторые понятия. У класса `Person` может быть имя и возраст. В разделе "Всё есть объект" мы говорили, что у объекта есть тип и он отвечает на ряд методов, которые — наша единственная возможность взаимодействовать с объектом. В общем, нам нужны методы `name` (имя) and `age` (возраст). Мы будем хранить эту информацию в переменных объекта, которые всегда начинаются со знака *коммерческое at* (`@`). А ещё нам нужно, чтобы объект класса `Person` создался сразу с выбранным нами именем и нулевым возрастом. Для этого мы опишем специальный метод `initialize`, который в общем случае называется *конструктором*:

```crystal
class Person
  def initialize(name : String)
    @name = name
    @age = 0
  end

  def name
    @name
  end

  def age
    @age
  end
end
```

Теперь мы можем создавать объекты вот так:

```crystal
john = Person.new "John"
peter = Person.new "Peter"

john.name #=> "John"
john.age #=> 0

peter.name #=> "Peter"
```

(Если у вас возник вопрос, почему мы должны были указать для `name` тип `String`, но не сделали этого для `age`, прочитайте про [алгоритм вывода общего типа](type_inference.html))

Обратите внимание, что мы создали `Person` при помощи `new`, но определили инициализацию в методе `initialize`, не в методе `new`. Почему так?

Смысл в том, что при определении метода `initialize` Crystal определил метод `new` сам. Примерно так:

```crystal
class Person
  def self.new(name : String)
    instance = Person.allocate
    instance.initialize(name)
    instance
  end
end
```

Во-первых, обратите внимание на запись `self.new`. Она значит, что метод принадлежит **классу** `Person`, а не отдельным экземплярам этого класса. Именно поэтому мы можем использовать  `Person.new`.

Во-вторых, `allocate` — это метод низкоуровневого класса, который создаёт неинициализированный объект заданного типа. Он по сути выделяет необходимую память для него. Затем вызывается `initialize` и мы получаем экземпляр класса. Вы, как правило, никогда не должгы вызывать `allocate`, так как это [небезопасно](unsafe.html), и именно поэтому используются методы `new` и `initialize`.
